---
description: General layout for files in a standard web-service style implementation.
alwaysApply: true
glob: **/src/**/*.ts
---

# General Rules for NestJS
- Service Objects should generally not be created with thew new keyword, they should always be created via constructor injection.
- passing around a reference to the injection context should be avoided.
- Functionality should not be encoded in data objects, it should be implemented in a service object. These services objects are singeltons and must not contain application state unless it's a cache of static values.

# Code organization in terms of responsiblities

- NestJS GraphQL and HTTP services:
  - The general flow of execution will proceed from a Resolver or Controller, via Guards and deserializers, through a set of Service objects leveraging transformers to interact with Repository objects that interact with the datastore. Data is returned from a service object, serialized, and the returned from the controller or resolver object.

- Resolvers and Controllers
  - Resolvers and Controllers are responsible for implementing only syntactical validation, input transformation and output transormation in the essence of deserialization and serialization. They should have an AuthGuard in most cases.
  - Resolvers always delegate to service object calls for any business logic.
  - Resolvers always delegate to service object calls to access data from a datastore.
- Service Objects
  - Service objects are business logic classes, and should delegate datasource calls to Repository objects.
  - files are named using the nestJS convention: my-thing.service.ts
- Repository objects 
  - Repository objects are responsible for interactions with datasources the receives data from. This includes databases, both SQL and NoSQL, and external API driven services.
  - Repository objects are the ONLY place where interactions with the datasource may occur. In the case of Sequelize this is any call to the Entity classes.
  - Repository objects responsible for datastore interaction are always suffixed with the name 'Repository'.
  - Repository objects are named using the nestJS convention: my-thing.repository.ts
- Transformer Objects
  - Are responsible for converting data that is read from the datasource in Entity form into business objects suitable for the service layer.
  - Are reponsible for converting data that is received from the service layer into Entity form to be written into the datasource.
  - May also contain a default entity shape so that a repository class can bootsrap an empty Entity with the appropriate initialized fields.
  - Also contain a validation method to screen data received from the datastore can be converted into a business object, and produce appropriate behavior when it cannot including:
    - Logging when an entity is received that cannot be transformed.
    - Skipping it if it is considered non-fatal to not be able to convert the data.
    - Producing and exception when it is considered fatal.
  - Transformer objects are named as my-thing-transformer.service.ts and are generally treated like other service objects.
  - Transformation methods will be implemented as async methods.