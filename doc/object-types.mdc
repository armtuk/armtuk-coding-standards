---
description: This rule enforces object variants fundamentals.
globs: **/src/*.ts,**/src/*.java
alwaysApply: true
---
# Defining Objects

## Object Types
There are 5 fundamental types of objects:

1. State and Data Containing Objects
2. Companion Objects & Proxy Classes
3. Service Objects
4. Utility Objects
5. Algebraic Datatypes

## State and Data Containing Objects

- State and Data containing objects are objects which contain information. 
- Information is specifically data elements that represent knowledge in the real world. 
- An address is a piece of data.  A Customer's name is a piece of data. 
- These objects come in two forms, and in two variants of those forms which are:
  - Data objects, which contain only data. Interfaces in JavaScript are data objects.
  - Model objects, which contain both data and functionality related to that data. Classes in JavaScript can be model objects.
- Within those two forms we have two ways of treating these objects
  - Mutable. The data in this model object is subject to change within an instance after it has been instantiated.
  - Immutable. The data in this model object is unchanging once the class has been instantiated. 
- Immutable data and model objects are preferred except in the case where we are applying the "Enricher" enterprise integration pattern as documented by Martin Fowler.
- A function that relates to a model that needs to be asynchronous must be placed inside a service object.
- Service objects must be created from the injection context except in test cases.
- Service objects contain:
  - methods for performing transformations on model instance
  - internal storage that contains ONLY metadata related to the system.
- Application state may only be contained within Model Objects which are always transient and scoped at most to a request context.

### Composite Objects

- Composite objects are used to contain a logic grouping of data or model objects. 
- An Example of this is a relational database result that represents a hierarchy, like an Organization, and an Organization's Employees. The database object that represents just an Organization alone contains just the metadata about the organization. 
  - A composite data object named OrganizationEmployees will contain the organization's metadata AND the list of all Employees objects as child objects.

    ```java
    package com.example.myservice.dao.model;

    @AllArgsConstructor
    @Data
    public class OrganizationEmployees {
        public final OrganizationRow organization
        public final List[EmployeeRow] employees
    }
    ```

```typescript
export class OrganzationEmployees {
  contructor(
    public readonly organization: Organization, 
    public readonly employees: EmployeeRow[]
  ) {}
}
```

This is useful as the model object within the application may choose to represent this data as a single object, and we may choose to represent the initialization from the composite as a constructor, or we can choose to make that itself a service object too, depending.

```java
package com.example.myservice.model;

@AllArgsConstructor
@Data
public class Organization {
  public final String name
  public final List[EmployeeRow] employees
  public Organization(OrganizationEmployees x) {
     this.name = x.organization.name
     this.employees = x.employees
  }
}
```

### State and Data Objects

- A data object is an object that contains only data and no methods.
- Data objects are present in systems where they are autogenerated. A TypeORM Entity class is an example of a Data Object. It contains only the database fields mapped to class fields and any relationships.

### Model Object

- A Model object contains both data and logic. 
- The logic in a Model object is isolated to the data within that specific Model Object. 
- It is instantiated by service objects.
- It is used to contain data in transit.
- It is used to express the structure of data acting as a type bound for code that interacts with that data.
- It is strict and complete, i.e. business logic can rely that it contains valid data only.
  - A value in a model object may not be null unless it is explicitly permitted. In Java this is the use of the "Optional" or "Option" monadic wrapper. In TypeScript this is an explicit type union which includes null or/and undefined.

## Companion Objects & Proxy Classes

- Companion objects are used to bridge the gap between data classes and service objects. Where data classes are missing core functionality for themselves to cover things like simple validation, or deep introspection/retrieval, like getting Line Items from an Order Document this is where companion objects are used. 
- Companion objects can also be used to describe behaviour about a class of objects. In Scala and Haskell these type of objects are referred to as a "Type Class". In other languages that lack a formal "Type Class", they are described as "Companion Objects".

Here is an example proxy model that is used to wrap the original object to provide additional functionality.

```java
class MyClass {
  private final NestedThing nestedThing
  ...
}
class MyClassProxy implements MyClassInterface {
  private final MyClass original;
  public MyClassWrapper(MyClass original) {
     this.original = original
  }
  
  public Optional<String> getNestedAttribute(String name) {
     if (nestedThing.hasAttribute(name) 
        return Optional.ofNullable(nestedThing.get(name));
     else
        return Optional.empty();
  }
}
```

Use a Proxy object when the recipient of such a class needs to interact with a specific Type bound argument, and additional or overridden functionality is needed.

## Service Objects

- Service objects are objects that perform business logic. 
- Each method in a service object represents a type arrow, i.e. it receives an input of a given data or composite object and yields a result of the same or a different type of object or composite object.
  - An example method would be translating an OrderDocument to a FraudDocument. 
- Service objects are always instantiated through dependency injection.
- To do these transformations, they will depend on other external services, like data sources or enrichment systems.
  - These other services are injected into the service object by the dependency injection framework.
- Service objects are singletons.
- Service objects are named based on the service they provide.


## Utility Object

- Utility objects are used to group small pieces of common functionality whose scope is above any single module. 
- Common examples of utility objects are objects that interact with things like:
  - Dates
  - Strings
  - Streams
  - Lists and other Collections.
- These types of methods are outside the scope of any single feature and so are grouped in a common utility object.
- Utility objects live in the common/ folder of a project.

## Algebraic Datatypes

Algebraic Datatypes represent algorithms and data structures. 
- Examples are things like Abstract Syntax Trees. 
- Algebraic datatypes leverage inheritance to function.

An example algebraic data type is a naive implementation of Option:
```Typescript
export interface IOption<T> {
  get(): T
  map<U>(f: (x: T) => U): U
  isPresent(): boolean
}

export class Some<T> implements IOption<T> {
  constructor(private value: T) {}
  get(): T {
    return value;
  }
  map<U>(f: (x: T) => U): U {
    return new Some(f(value))
  }
  isPresent = () => false
}

export class None<T> implements IOption<T> {
  constructor() {}
  get(): T { throw new Error("Empty value")}
  map<U>(f: (x: T) => U): U {
    return new None<U>()
  }
  isPresent = () => false
}

export type Option<T> = None<T> | Some<T>
```

```Java
abstract class Option<T> {
    T get()
    U map<U>(Function<T, U> f);
    Boolean isPresent();
}

class Some<T> extends Option<T> {
    T value
    public Some(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }

    public U map<U>(Function<T, U> f) {
        return new Some(f.apply(value));
    }
}

class None<T> extends Option<T> {
    public None() {}

    public T get() {
        throw InvalidStateException("None has no value");
    }

    public U map<U>(Function<T, U> f) {
        return new None<U>();
    }
}
```

## Naming Objects and Datastore Relations and Tables

Objects are named for what data aggregate, datum, domain, or third-party interaction they are responsible for. Each fundamental object type is named slightly differently:
- Service object are named based on domain they are responsible for. An object that is responsible for the User domain will be named UserService.
A service object responsible for interacting with Twitter will be named TwitterService
  - In typescript the file would be named user.service.ts
  - In Java the file would be named UserService.java
  - in Scala the file would be named UserService.scala
When a service object has multiple variants, is polymorphic, these variants should inherit from an Interface.
  - The interface can be named for the basic case, or with an 'I' prefix:
    - ```typescript
      export interface SlackService {
        async post(post: SlackPost): Promise<SlackPostResult>
      }```
  - Derived classes are named based on that which makes them distinctive, for example:
    - ```typescript
      export class OAuthSlackService implements SlackService {
        async post(post: SlackPost): Promise<SlackPostResult> {
          ...
        }
      }```
    - ```typscript
      export class SAMLSlackService implements SlackService {
        ...
      }```
- Repository objects are named based on the Entity or Entity Aggregate they perform functions for.  A repository interacting with User data 
would be named UserRepository.
  - In typescript the file would be named user.repository.ts
  - In Java the file would be named UserRepository.java
  - in Scala the file would be named UserRepository.scala
- Model and Data objects are named based on the name of an Object abstraction like 'User' or 'Person' or 'Address'. If the object is representing a database table in a relational database, it will be named with an Entity suffix such as 'UserEntity' or 'AddressEntity'.
- Model and Data objects should be named for the singular rather than the plural.
- Methods within an Object are named as commands.
  - Commands that perform a function are named as a command generally of the form <verb> <command> leveraging camel case such as:
    - changePassword
    - updateKYCInfo
    - processOrder
  - Methods that retrieve data are named prefixed with 'fetch' when a remote datastore interaction is required, and 'get' otherwise.
    - fetchObjectName
    - getLocalData
  - In TypeScript it is appropriate to seperate context groups into Higher Order functions:
    - ```typescript
      export class MyExample<T> {
        aComplexFunction = (context: Context) => (maybeArgument: string = "") => async <U>(definiteFunctionalArgument: (x: T) => U): Promise<U> => {
          return "my-result"
        }
      }```
    - Function arguments should be the last argument group.
- Database Tables that store this data should also be named for the singular rather than the plural.
- Database table and column names should follow the ANSI standard which uses underscores to separate words except when a project has a prior convention established.
- Database Tables that logically link two Relations/Objects together should be named for both with the Parent object first.
  - A table linking User and Address would be named user_address
  - A table linking Address and City would name address_city
  - Table ID columns are named 'id'.
  - Foreign key columns are named for the destination table with an id suffix such as
    - The ID of the address relation on address_city would be named address_id, and be a foreign key to the column named 'id' on the address table
    - The ID of the city relation on address_city would be city_id, and be a foreign key to the column named 'id' on the city table.
  - ID columns should be either numeric and generated from a database sequence, or string and be genered by a UUID function.
  - Unique columns that are textual in nature prefer the '_code' suffix.
  - Indexes are suffixed with '_i' for a regular index, and '_ui' for a unique index
