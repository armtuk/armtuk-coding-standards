---
description: This rule enforces object variants fundamentals.
globs: **/src/*.ts,**/src/*.java
alwaysApply: true
---
# Defining Objects

## Object Types
There are 5 fundamental types of objects:

1. State and Data Containing Objects
2. Companion Objects & Proxy Classes
3. Service Objects
4. Utility Objects
5. Algebraic Datatypes

## State and Data Containing Objects

- State and Data containing objects are objects which contain information. 
- Information is specifically data elements that represent knowledge in the real world. 
- An address is a piece of data.  A Customer's name is a piece of data. 
- These objects typically come in two forms, and in two variants of those forms. 
- The two forms are: 
  - Data objects, which contain only data. Interfaces in JavaScript are data objects.
  - Model objects, which contain both data and functionality related to that data. Classes in JavaScript can be model objects.
- Within those two forms we have two ways of treating these objects
  - Mutable. The data in this model is subject to change within an instance.
  - Immutable. The data in this is unchanging once the class has been instantiated. 
- Immutable data and model objects are preferred except in the case where we are applying the "Enhance" enterprise integration pattern.
- A function that relates to a model that needs to be asynchronous must be placed inside a service object.
- Service objects must be created from the injection context except in test cases.

### Composite Objects

- Composite objects are used to contain a logic grouping of data or model objects. 
- An Example of this is a relational database result that represents a hierarchy, like an Organization, and an Organization's Employees. The database object that represents just an Organization alone contains just the metadata about the organization. 
  - A composite data object named OrganizationEmployees will contain the organization's metadata AND the list of all Employees objects as child objects.

    ```java
    package com.example.myservice.dao.model;

    @AllArgsConstructor
    @Data
    public class OrganizationEmployees {
        public final OrganizationRow organization
        public final List[EmployeeRow] employees
    }
    ```

```typescript
export class OrganzationEmployees {
  contructor(
    public readonly organization: Organization, 
    public readonly employees: EmployeeRow[]
  ) {}
}
```

This is useful as the model object within the application may choose to represent this data as a single object, and we may choose to represent the initialization from the composite as a constructor, or we can choose to make that itself a service object too, depending.

```java
package com.example.myservice.model;

@AllArgsConstructor
@Data
public class Organization {
  public final String name
  public final List[EmployeeRow] employees
  public Organization(OrganizationEmployees x) {
     this.name = x.organization.name
     this.employees = x.employees
  }
}
```

### State and Data Objects

- A data object is an object that contains only data and no methods.
- Data objects are present in systems where they are autogenerated. A TypeORM Entity class is an example of a Data Object. It contains only the database fields mapped to class fields and any relationships.

### Model Object

- A Model object contains both data and logic. 
- The logic in a Model object is isolated to the data within that specific Model Object. 
- It is instantiated by service objects.
- It is used to contain data in transit.
- It is used to express the structure of data acting as a type bound for code that interacts with that data.
- It is strict and complete, i.e. business logic can rely that it contains valid data only.
  - A value in a model object may not be null unless it is explicitly permitted. In Java this is the use of the "Optional" or "Option" monadic wrapper. In TypeScript this is an explicit type union which includes null or/and undefined.

## Companion Objects & Proxy Classes

- Companion objects are used to bridge the gap between data classes and service objects. Where data classes are missing core functionality for themselves to cover things like simple validation, or deep introspection/retrieval, like getting Line Items from an Order Document this is where companion objects are used. 
- Companion objects can also be used to describe behaviour about a class of objects. In Scala and Haskell these type of objects are referred to as a "Type Class". In other languages that lack a formal "Type Class", they are described as "Companion Objects".

Here is an example proxy model that is used to wrap the original object to provide additional functionality.

```java
class MyClass {
  private final NestedThing nestedThing
  ...
}
class MyClassProxy implements MyClassInterface {
  private final MyClass original;
  public MyClassWrapper(MyClass original) {
     this.original = original
  }
  
  public Optional<String> getNestedAttribute(String name) {
     if (nestedThing.hasAttribute(name) 
        return Optional.ofNullable(nestedThing.get(name));
     else
        return Optional.empty();
  }
}
```

Use a Proxy object when the recipient of such a class needs to interact with a specific Type bound argument, and additional or overridden functionality is needed.

## Service Objects

- Service objects are objects that perform business logic. 
- Each method in a service object represents a type arrow, i.e. it receives an input of a given data or composite object and yields a result of the same or a different type of object or composite object.
  - An example method would be translating an OrderDocument to a FraudDocument. 
- Service objects are always instantiated through dependency injection.
- To do these transformations, they will depend on other external services, like data sources or enrichment systems.
  - These other services are injected into the service object by the dependency injection framework.
- Service objects are singletons.
- Service objects are named based on the service they provide.


## Utility Object

- Utility objects are used to group small pieces of common functionality whose scope is above any single module. 
- Common examples of utility objects are objects that interact with things like:
  - Dates
  - Strings
  - Streams
  - Lists and other Collections.
- These types of methods are outside the scope of any single feature and so are grouped in a common utility object.
- Utility objects live in the common/ folder of a project.

## Algebraic Datatypes

Algebraic Datatypes represent algorithms and data structures. 
- Examples are things like Abstract Syntax Trees. 
- Algebraic datatypes leverage inheritance to function.

An example algebraic data type is a naive implementation of Option:
```Typescript
interface class IOption<T> {
  T get()
  U map<U>(f: (x: T => U)
  isPresent(): boolean
}

export class Some<T> implements IOption<T> {
  public constructor(private T value) {}
  public T get() {
    return value;
  }
  public U map<U>(f: (x: T) => U) {
    return new Some(f(value))
  }
}

export class None<T> implements IOption<T> {
  public constructor() {}
  public T get() { throw new Error("Empty value")}
  public U map<U>(f: (x: T) => U) {
    return new None<U>()
  }
}

export type Option<T> = None<T> | Some<T>
```

```Java
abstract class Option<T> {
    T get()
    U map<U>(Function<T, U> f);
    Boolean isPresent();
}

class Some<T> extends Option<T> {
    T value
    public Some(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }

    public U map<U>(Function<T, U> f) {
        return new Some(f.apply(value));
    }
}

class None<T> extends Option<T> {
    public None() {}

    public T get() {
        throw InvalidStateException("None has no value");
    }

    public U map<U>(Function<T, U> f) {
        return new None<U>();
    }
}
```
